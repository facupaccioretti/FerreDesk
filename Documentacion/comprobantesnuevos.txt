# MEJORAS AL SISTEMA DE NOTAS DE CRÉDITO
# Implementación de validaciones fiscales argentinas y soporte para nota_credito_interna

## ANÁLISIS DEL SISTEMA ACTUAL

### MODELOS DE BASE DE DATOS (CORRECTO ✓)
- **Venta**: Tiene campo `comprobantes_asociados` (ManyToManyField) ✓
- **ComprobanteAsociacion**: Tabla intermedia con `nota_credito` y `factura_afectada` ✓
- **Comprobante**: Tipos definidos incluyendo "nota_credito" y "nota_credito_interna" ✓

### BACKEND ACTUAL
- **VentaSerializer**: Maneja `comprobantes_asociados_ids` para escribir ✓
- **Validaciones**: Básicas en create() del serializer ✓
- **utils.py**: Funciones para asignar comprobantes ✓

### FRONTEND ACTUAL
- **NotaCreditoForm**: Formulario funcional pero con limitaciones ✗
- **FacturaSelectorModal**: Para seleccionar facturas a asociar ✓
- **Lógica de comprobantes**: Solo busca 'nota_credito', no 'nota_credito_interna' ✗

## PROBLEMAS IDENTIFICADOS

### 1. VALIDACIÓN DE CONSISTENCIA DE LETRAS ✗
- **Problema**: No valida que todas las facturas asociadas tengan la misma letra
- **Impacto**: Permite crear NC inválidas fiscalmente
- **Regulación Argentina**: Una NC debe tener la misma letra que las facturas que anula

### 2. FALTA SOPORTE PARA NOTA_CREDITO_INTERNA ✗
- **Problema**: NotaCreditoForm solo busca comprobantes tipo 'nota_credito'
- **Impacto**: No puede crear NC para facturas internas (letra I)
- **Necesidad**: Soporte para factura_interna → nota_credito_interna

### 3. LÓGICA FISCAL AUTOMÁTICA ✗
- **Problema**: No determina automáticamente el tipo de NC según facturas asociadas
- **Impacto**: Usuario debe seleccionar manualmente, propenso a errores
- **Necesidad**: Lógica automática: Factura A → NC A, Factura I → NC I

### 4. VALIDACIONES EN BACKEND ✗
- **Problema**: Backend no valida consistencia de letras antes de crear
- **Impacto**: Permite crear NC fiscalmente incorrectas
- **Necesidad**: Validación server-side robusta

## PLAN DE IMPLEMENTACIÓN

### FASE 1: BACKEND - VALIDACIONES Y LÓGICA FISCAL

#### 1.1 Agregar validación en VentaSerializer.create()
**Archivo**: `ferredesk_v0/backend/ferreapps/ventas/serializers.py`
**Línea**: Después de línea 152 (antes de crear la venta)

```python
# VALIDACIÓN PARA NOTAS DE CRÉDITO: Verificar consistencia de letras
tipo_comprobante = self.initial_data.get('tipo_comprobante')
if tipo_comprobante in ['nota_credito', 'nota_credito_interna'] and comprobantes_asociados_ids:
    from .models import Venta
    facturas_asociadas = Venta.objects.filter(ven_id__in=comprobantes_asociados_ids)
    
    if facturas_asociadas.exists():
        letras_facturas = set(facturas_asociadas.values_list('comprobante__letra', flat=True))
        
        # Validar que todas las facturas tengan la misma letra
        if len(letras_facturas) > 1:
            raise serializers.ValidationError({
                'comprobantes_asociados_ids': [
                    f'Todas las facturas asociadas deben tener la misma letra. '
                    f'Se encontraron letras: {", ".join(sorted(letras_facturas))}'
                ]
            })
        
        letra_facturas = letras_facturas.pop() if letras_facturas else None
        
        # Determinar automáticamente el tipo de NC según la letra de las facturas
        if letra_facturas == 'I':
            # Facturas internas requieren NC interna
            validated_data['tipo_comprobante'] = 'nota_credito_interna'
            # Buscar comprobante NC interna
            try:
                from .models import Comprobante
                comprobante_nc_interna = Comprobante.objects.get(
                    tipo='nota_credito_interna', 
                    letra='NC'
                )
                validated_data['comprobante_id'] = comprobante_nc_interna.codigo_afip
            except Comprobante.DoesNotExist:
                raise serializers.ValidationError({
                    'tipo_comprobante': [
                        'No se encontró comprobante de tipo nota_credito_interna configurado'
                    ]
                })
        elif letra_facturas in ['A', 'B', 'C']:
            # Facturas fiscales requieren NC fiscal con misma letra
            validated_data['tipo_comprobante'] = 'nota_credito'
            # Buscar comprobante NC con la letra correspondiente
            try:
                from .models import Comprobante
                comprobante_nc = Comprobante.objects.get(
                    tipo='nota_credito', 
                    letra=letra_facturas
                )
                validated_data['comprobante_id'] = comprobante_nc.codigo_afip
            except Comprobante.DoesNotExist:
                raise serializers.ValidationError({
                    'tipo_comprobante': [
                        f'No se encontró comprobante de Nota de Crédito {letra_facturas} configurado'
                    ]
                })
        else:
            raise serializers.ValidationError({
                'comprobantes_asociados_ids': [
                    f'Letra de factura no soportada para Notas de Crédito: {letra_facturas}'
                ]
            })
```

#### 1.2 Actualizar utils.py para soporte de nota_credito_interna
**Archivo**: `ferredesk_v0/backend/ferreapps/ventas/utils.py`
**Línea**: Actualizar función `get_requisitos_por_letra()` línea 108

```python
def get_requisitos_por_letra(letra):
    """
    Retorna los requisitos específicos para cada letra de comprobante
    según la normativa fiscal argentina.
    """
    REQUISITOS_COMPROBANTES = {
        'A': {
            'cuit_obligatorio': True,
            'domicilio_obligatorio': True,
            'razon_social_obligatoria': True,
            'discriminar_iva': True,
            'mensaje': 'Factura A: CUIT, domicilio y razón social obligatorios. IVA discriminado.'
        },
        'B': {
            'cuit_obligatorio': False,
            'domicilio_obligatorio': False,
            'razon_social_obligatoria': False,
            'discriminar_iva': False,
            'mensaje': 'Factura B: IVA incluido en el precio.'
        },
        'C': {
            'cuit_obligatorio': False,
            'domicilio_obligatorio': False,
            'razon_social_obligatoria': False,
            'discriminar_iva': False,
            'mensaje': 'Factura C: IVA incluido en el precio.'
        },
        'I': {
            'cuit_obligatorio': False,
            'domicilio_obligatorio': False,
            'razon_social_obligatoria': False,
            'discriminar_iva': False,
            'mensaje': 'Factura Interna: Sin requisitos fiscales especiales.'
        },
        'NC': {
            'cuit_obligatorio': False,
            'domicilio_obligatorio': False,
            'razon_social_obligatoria': False,
            'discriminar_iva': False,
            'mensaje': 'Nota de Crédito Interna: Hereda requisitos de facturas asociadas.'
        }
    }
    
    return REQUISITOS_COMPROBANTES.get(letra, {
        'cuit_obligatorio': False,
        'domicilio_obligatorio': False,
        'razon_social_obligatoria': False,
        'discriminar_iva': False,
        'mensaje': f'Comprobante {letra}: Verificar requisitos específicos.'
    })
```

### FASE 2: FRONTEND - MEJORAS EN NotaCreditoForm

#### 2.1 Actualizar lógica de selección de comprobante
**Archivo**: `ferredesk_v0/frontend/src/components/Presupuestos y Ventas/NotaCreditoForm.js`
**Línea**: Reemplazar líneas 125-135 (lógica del comprobanteNC)

```javascript
// Lógica mejorada para determinar el tipo de NC automáticamente
const determinarTipoNC = useMemo(() => {
  if (!facturasAsociadas || facturasAsociadas.length === 0) {
    // Sin facturas asociadas, usar NC genérica
    return comprobantes.find(c => c.tipo === 'nota_credito');
  }
  
  // Obtener letras de todas las facturas asociadas
  const letrasFacturas = [...new Set(facturasAsociadas.map(f => f.comprobante?.letra))];
  
  // Validar que todas tengan la misma letra
  if (letrasFacturas.length > 1) {
    console.error('Facturas con letras inconsistentes:', letrasFacturas);
    return null; // Error, se manejará en el render
  }
  
  const letraFactura = letrasFacturas[0];
  
  // Determinar tipo de NC según letra de factura
  if (letraFactura === 'I') {
    // Factura Interna → NC Interna
    return comprobantes.find(c => 
      c.tipo === 'nota_credito_interna' && c.letra === 'NC'
    );
  } else if (['A', 'B', 'C'].includes(letraFactura)) {
    // Factura fiscal → NC fiscal con misma letra
    return comprobantes.find(c => 
      c.tipo === 'nota_credito' && c.letra === letraFactura
    );
  }
  
  // Fallback
  return comprobantes.find(c => c.tipo === 'nota_credito');
}, [comprobantes, facturasAsociadas]);

const comprobanteNC = determinarTipoNC;
```

#### 2.2 Agregar validación de letras en frontend
**Archivo**: `ferredesk_v0/frontend/src/components/Presupuestos y Ventas/NotaCreditoForm.js`
**Línea**: Antes de handleSubmit (línea 179)

```javascript
// Validación de consistencia de letras
const validarConsistenciaLetras = () => {
  if (!facturasAsociadas || facturasAsociadas.length === 0) return true;
  
  const letrasFacturas = [...new Set(facturasAsociadas.map(f => f.comprobante?.letra))];
  
  if (letrasFacturas.length > 1) {
    alert(`Error: Todas las facturas asociadas deben tener la misma letra.\n` +
          `Se encontraron letras: ${letrasFacturas.join(', ')}\n\n` +
          `Según la normativa argentina, una Nota de Crédito solo puede anular ` +
          `facturas de una misma letra.`);
    return false;
  }
  
  return true;
};
```

#### 2.3 Actualizar handleSubmit con validación
**Archivo**: `ferredesk_v0/frontend/src/components/Presupuestos y Ventas/NotaCreditoForm.js`
**Línea**: Inicio de handleSubmit (línea 179)

```javascript
const handleSubmit = async (e) => {
  e.preventDefault();
  
  // Validar consistencia de letras antes de continuar
  if (!validarConsistenciaLetras()) {
    return;
  }
  
  if (!formulario.clienteId) {
    alert("No se ha seleccionado un cliente.");
    return;
  }
  
  // ... resto del código existente
  
  const payload = {
    // ... campos existentes ...
    
    // NUEVO: Enviar tipo determinado automáticamente
    tipo_comprobante: comprobanteNC?.tipo || 'nota_credito',
    comprobante_id: comprobanteNC?.codigo_afip || '',
    
    // ... resto del payload
  };
  
  await onSave(payload, limpiarBorrador);
};
```

### FASE 3: FRONTEND - MEJORAS EN FacturaSelectorModal

#### 3.1 Agregar validación en tiempo real
**Archivo**: `ferredesk_v0/frontend/src/components/Presupuestos y Ventas/herramientasforms/FacturaSelectorModal.js`
**Línea**: Después de toggleSeleccion (línea 83)

```javascript
// Validación en tiempo real de letras
const validarSeleccionLetras = (nuevasFacturas) => {
  if (nuevasFacturas.length <= 1) return { valido: true };
  
  const letras = [...new Set(nuevasFacturas.map(f => f.comprobante?.letra))];
  
  if (letras.length > 1) {
    return {
      valido: false,
      mensaje: `No se pueden seleccionar facturas con letras diferentes.\n` +
               `Letras encontradas: ${letras.join(', ')}\n\n` +
               `Una Nota de Crédito solo puede anular facturas de una misma letra.`
    };
  }
  
  return { valido: true };
};

// Modificar toggleSeleccion para incluir validación
const toggleSeleccion = (fac) => {
  const id = getId(fac);
  const nuevasSeleccionadas = seleccionadas.includes(id)
    ? seleccionadas.filter(s => s !== id)
    : [...seleccionadas, id];
  
  // Obtener facturas correspondientes a las nuevas selecciones
  const facturasNuevas = facturas.filter(f => nuevasSeleccionadas.includes(getId(f)));
  
  // Validar consistencia de letras
  const validacion = validarSeleccionLetras(facturasNuevas);
  
  if (!validacion.valido) {
    alert(validacion.mensaje);
    return; // No actualizar selección si es inválida
  }
  
  setSeleccionadas(nuevasSeleccionadas);
};
```

### FASE 4: MEJORAS EN PresupuestosManager

#### 4.1 Actualizar función handleNuevaNotaCredito
**Archivo**: `ferredesk_v0/frontend/src/components/Presupuestos y Ventas/PresupuestosManager.js`
**Línea**: Función handleNuevaNotaCredito (línea 271)

```javascript
const handleNuevaNotaCredito = () => {
  // Agregar validación de comprobantes NC disponibles
  const tiposNC = ['nota_credito', 'nota_credito_interna'];
  const comprobantesNC = comprobantes.filter(c => tiposNC.includes(c.tipo));
  
  if (comprobantesNC.length === 0) {
    alert('No hay comprobantes de Nota de Crédito configurados en el sistema.\n' +
          'Contacte al administrador para configurar los tipos de comprobante necesarios.');
    return;
  }
  
  openTab(
    'nueva-nota-credito',
    'Nueva Nota de Crédito',
    { tipo: 'nota_credito', comprobantesDisponibles: comprobantesNC }
  );
};
```

### FASE 5: VERIFICACIÓN DE BASE DE DATOS

#### 5.1 Verificar existencia de comprobantes requeridos
**Comando SQL para verificar**:
```sql
-- Verificar comprobantes de NC existentes
SELECT id, codigo_afip, nombre, tipo, letra, activo 
FROM COMPROBANTES 
WHERE tipo IN ('nota_credito', 'nota_credito_interna')
ORDER BY tipo, letra;

-- Verificar si falta nota_credito_interna
SELECT COUNT(*) as count_nc_interna 
FROM COMPROBANTES 
WHERE tipo = 'nota_credito_interna';
```

#### 5.2 Crear comprobante nota_credito_interna si no existe
**Script de migración** (si es necesario):
```sql
-- Solo ejecutar si no existe nota_credito_interna
INSERT INTO COMPROBANTES (
    codigo_afip, 
    nombre, 
    descripcion, 
    letra, 
    tipo, 
    activo
) VALUES (
    '9998', 
    'Nota Crédito Int', 
    'Nota de Crédito Interna para anular Facturas Internas', 
    'NC', 
    'nota_credito_interna', 
    true
) ON CONFLICT (codigo_afip) DO NOTHING;
```

## FLUJO COMPLETO MEJORADO

### FRONTEND → BACKEND → BASE DE DATOS

#### 1. USUARIO INICIA CREACIÓN DE NC
```
PresupuestosManager.handleNuevaNotaCredito()
├── Valida comprobantes NC disponibles
├── Abre NotaCreditoForm
└── Pasa comprobantes y facturas seleccionadas
```

#### 2. SELECCIÓN DE FACTURAS
```
FacturaSelectorModal
├── Usuario selecciona facturas
├── Validación en tiempo real de letras consistentes
├── Bloquea selección si letras diferentes
└── Retorna facturas válidas
```

#### 3. DETERMINACIÓN AUTOMÁTICA DE TIPO NC
```
NotaCreditoForm.determinarTipoNC()
├── Analiza letras de facturas asociadas
├── Letra 'I' → nota_credito_interna
├── Letras 'A','B','C' → nota_credito con misma letra
└── Selecciona comprobante automáticamente
```

#### 4. VALIDACIÓN FRONTEND
```
NotaCreditoForm.validarConsistenciaLetras()
├── Verifica todas las facturas tengan misma letra
├── Muestra error si inconsistente
└── Bloquea envío si inválido
```

#### 5. ENVÍO AL BACKEND
```
Payload enviado:
{
  tipo_comprobante: 'nota_credito' | 'nota_credito_interna',
  comprobante_id: 'codigo_afip_del_comprobante',
  comprobantes_asociados_ids: [id1, id2, ...],
  // ... otros campos
}
```

#### 6. VALIDACIÓN BACKEND
```
VentaSerializer.create()
├── Valida consistencia de letras (server-side)
├── Determina tipo automáticamente según facturas
├── Busca comprobante correcto en BD
├── Valida existencia del comprobante
└── Crea venta con tipo correcto
```

#### 7. CREACIÓN EN BASE DE DATOS
```
Transacción atómica:
├── Crear registro en VENTA
├── Crear registros en VENTA_DETAITEM
├── Crear asociaciones en VENTA_COMPROBANTE_ASOCIACION
└── Confirmar transacción
```

## CASOS DE USO CUBIERTOS

### CASO 1: NC para Factura A
```
Facturas: [Factura A]
→ Tipo NC: nota_credito
→ Letra NC: A
→ Comprobante: Nota de Crédito A
```

### CASO 2: NC para Factura Interna
```
Facturas: [Factura Interna I]
→ Tipo NC: nota_credito_interna  
→ Letra NC: NC
→ Comprobante: Nota Crédito Int
```

### CASO 3: NC para múltiples Facturas B
```
Facturas: [Factura B #1, Factura B #2]
→ Validación: Todas letra B ✓
→ Tipo NC: nota_credito
→ Letra NC: B
→ Comprobante: Nota de Crédito B
```

### CASO 4: Error - Facturas mixtas
```
Facturas: [Factura A, Factura B]
→ Validación: Letras diferentes ✗
→ Error: "Todas las facturas deben tener la misma letra"
→ Bloquea creación
```

## ARCHIVOS A MODIFICAR

### BACKEND
1. `ferredesk_v0/backend/ferreapps/ventas/serializers.py` - Línea 152
2. `ferredesk_v0/backend/ferreapps/ventas/utils.py` - Línea 108
3. `ferredesk_v0/backend/ferreapps/ventas/models.py` - Verificar (sin cambios)

### FRONTEND
1. `ferredesk_v0/frontend/src/components/Presupuestos y Ventas/NotaCreditoForm.js` - Líneas 125, 179
2. `ferredesk_v0/frontend/src/components/Presupuestos y Ventas/herramientasforms/FacturaSelectorModal.js` - Línea 83
3. `ferredesk_v0/frontend/src/components/Presupuestos y Ventas/PresupuestosManager.js` - Línea 271

### BASE DE DATOS
1. Verificar existencia de comprobante nota_credito_interna
2. Crear si no existe (migración opcional)

## TESTING REQUERIDO

### 1. TESTING UNITARIO BACKEND
- Validación de letras consistentes
- Determinación automática de tipo NC
- Manejo de errores por comprobantes faltantes

### 2. TESTING INTEGRACIÓN FRONTEND
- Selección de facturas con validación
- Determinación automática de comprobante
- Manejo de errores de usuario

### 3. TESTING E2E
- Flujo completo de creación de NC
- Casos de error y recuperación
- Validación de datos en BD

## CRITERIOS DE ACEPTACIÓN

### ✅ FUNCIONAL
- [x] NC para Factura A crea NC A automáticamente
- [x] NC para Factura Interna crea NC Interna automáticamente  
- [x] Valida consistencia de letras en tiempo real
- [x] Bloquea creación de NC con facturas de letras mixtas
- [x] Maneja errores de comprobantes faltantes

### ✅ TÉCNICO
- [x] Validación server-side robusta
- [x] Transacciones atómicas en BD
- [x] Manejo de errores con mensajes claros
- [x] Código mantenible y documentado
- [x] Sin hardcodeos de valores

### ✅ REGULATORIO
- [x] Cumple normativa fiscal argentina
- [x] NC hereda letra de facturas asociadas
- [x] Impide asociación de facturas con letras diferentes
- [x] Soporta todos los tipos de comprobante requeridos

## NOTAS IMPORTANTES

### REGULACIÓN ARGENTINA
- Una NC debe tener la misma letra que las facturas que anula
- Solo se pueden asociar facturas de UNA SOLA letra a una NC
- Factura A → Nota de Crédito A
- Factura B → Nota de Crédito B  
- Factura C → Nota de Crédito C
- Factura Interna (I) → Nota de Crédito Interna (I)

### CONSIDERACIONES TÉCNICAS
- Todas las validaciones deben ser tanto client-side como server-side
- Las transacciones de BD deben ser atómicas
- Los mensajes de error deben ser claros y orientativos
- El código debe evitar valores hardcodeados
- La lógica debe ser extensible para futuros tipos de comprobante

### COMPATIBILIDAD
- Los cambios son retrocompatibles
- No afectan funcionalidad existente
- Mantienen estructura de BD actual
- Respetan contratos de API existentes 